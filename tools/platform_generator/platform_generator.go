package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"

	"github.com/BurntSushi/toml"
)

type Config struct {
	Files       FilesConfig              `toml:"files"`
	RuffRelease RuffReleaseConfig        `toml:"ruff_release"`
	Platforms   map[string]PlatformEntry `toml:"platforms"`
}

type FilesConfig struct {
	VersionFile  string `toml:"version_file"`
	PlatformFile string `toml:"platform_file"`
}

type RuffReleaseConfig struct {
	BaseURL string `toml:"base_url"`
	File    string `toml:"file"`
	ArchKey string `toml:"arch_key"`
	Hash    string `toml:"hash"`
}

type PlatformEntry struct {
	Arch   string `toml:"arch"`
	OS     string `toml:"os"`
	Vender string `toml:"vender"`
	Ext    string `toml:"ext"`
}

func main() {
	// Define the named flag --config
	configPath := flag.String("config", "config.toml", "Path to configuration file")

	// Parse the named flags
	flag.Parse()

	var config Config
	if _, err := toml.DecodeFile(*configPath, &config); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to read config file: %v\n", err)
		os.Exit(1)
	}

	// Output the values
	fmt.Printf("Config file: %v\n", config)

	archKey := config.RuffRelease.ArchKey
	archKey = strings.ReplaceAll(archKey, "{", "{{.")
	archKeyTemplate := strings.ReplaceAll(archKey, "}", "}}")

	cpuPlatforms := map[string]string{
		"x86_64":  "@platforms//cpu:x86_64",
		"aarch64": "@platforms//cpu:aarch64",
	}
	osPlatforms := map[string]string{
		"linux-gnu":    "@platforms//os:linux",
		"windows-msvc": "@platforms//os:windows",
		"darwin":       "@platforms//os:macos",
	}

	path := config.Files.PlatformFile
	file, err := os.OpenFile(path, os.O_RDWR, 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to open file: %v\n", err)
		os.Exit(1)
	}
	defer file.Close()

	file.Truncate(0) // Clear the file
	file.Seek(0, 0)  // Move the cursor to the beginning

	if _, err := file.WriteString("\"\"\"Platform definitions supported by this rule.\n"); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
		os.Exit(1)
	}
	if _, err := file.WriteString("\n"); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
		os.Exit(1)
	}
	if _, err := file.WriteString("THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n"); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
		os.Exit(1)
	}
	if _, err := file.WriteString("\n"); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
		os.Exit(1)
	}
	if _, err := file.WriteString("Run the following command to generate this file from the '//:config.toml'.\n"); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
		os.Exit(1)
	}
	if _, err := file.WriteString("$ bazel run //tools/platform_generator\n"); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
		os.Exit(1)
	}
	if _, err := file.WriteString("\"\"\"\n"); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
		os.Exit(1)
	}
	if _, err := file.WriteString("\n"); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
		os.Exit(1)
	}

	if _, err := file.WriteString("RUFF_PLATFORMS = {\n"); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
		os.Exit(1)
	}

	keys := make([]string, 0, len(config.Platforms))
	for k := range config.Platforms {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, k := range keys {
		value := config.Platforms[k]

		data := map[string]string{
			"arch":   value.Arch,
			"vender": value.Vender,
			"os":     value.OS,
		}
		var buf bytes.Buffer
		err := template.Must(template.New("example").Parse(archKeyTemplate)).Execute(&buf, data)
		if err != nil {
			panic(err)
		}
		key := buf.String()
		line := fmt.Sprintf("    \"%s\": struct(", key)
		if _, err := file.WriteString(line + "\n"); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
			os.Exit(1)
		}
		line = fmt.Sprintf("        compatible_with = [")
		if _, err := file.WriteString(line + "\n"); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
			os.Exit(1)
		}
		line = fmt.Sprintf("            \"%s\",", osPlatforms[value.OS])
		if _, err := file.WriteString(line + "\n"); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
			os.Exit(1)
		}
		line = fmt.Sprintf("            \"%s\",", cpuPlatforms[value.Arch])
		if _, err := file.WriteString(line + "\n"); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
			os.Exit(1)
		}
		line = fmt.Sprintf("        ],")
		if _, err := file.WriteString(line + "\n"); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
			os.Exit(1)
		}
		line = fmt.Sprintf("        vender = \"%s\",", value.Vender)
		if _, err := file.WriteString(line + "\n"); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
			os.Exit(1)
		}
		line = fmt.Sprintf("        arch = \"%s\",", value.Arch)
		if _, err := file.WriteString(line + "\n"); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
			os.Exit(1)
		}
		line = fmt.Sprintf("        os = \"%s\",", value.OS)
		if _, err := file.WriteString(line + "\n"); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
			os.Exit(1)
		}
		line = fmt.Sprintf("        ext = \"%s\",", value.Ext)
		if _, err := file.WriteString(line + "\n"); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
			os.Exit(1)
		}
		line = fmt.Sprintf("    ),")
		if _, err := file.WriteString(line + "\n"); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
			os.Exit(1)
		}
	}

	if _, err := file.WriteString("}\n"); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing to file: %v\n", err)
		os.Exit(1)
	}
}
